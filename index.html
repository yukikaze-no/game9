<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhythm Game PWA</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="manifest" href="manifest.json">

  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: sans-serif;
      text-align: center;
      overflow: hidden;
    }
    #menu, #game, #result { margin-top: 20px; }
    canvas {
      background: #111;
      display: block;
      margin: 10px auto;
      touch-action: none;
      max-width: 100vw;
      max-height: 90vh;
    }
    button {
      padding: 10px 18px;
      margin: 6px;
      font-size: 18px;
      border-radius: 8px;
    }
  </style>
</head>

<body>

<!-- MENU -->
<div id="menu">
  <h2>Select Song & Difficulty</h2>
  <div id="songList"></div>
  <p>PC: S / D / K / L | Mobile: Tap the lanes</p>
</div>

<!-- GAME -->
<div id="game" style="display:none;">
  <h2 id="songTitle"></h2>
  <canvas id="canvas"></canvas>
  <p id="info"></p>
</div>

<!-- RESULT -->
<div id="result" style="display:none;">
  <h2>Result</h2>
  <p id="finalScore"></p>
  <p id="finalCombo"></p>
  <p id="finalJudge"></p>
  <button onclick="returnToMenu()">Back to Menu</button>
</div>

<script>
/* ------------------------------
   CANVAS SETUP
------------------------------ */
function isMobileDevice() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = 400;
canvas.height = 600;

if (isMobileDevice()) {
  canvas.style.width = (400 * 1.5) + "px";
  canvas.style.height = (600 * 1.5) + "px";
} else {
  canvas.style.width = "350px";
  canvas.style.height = "525px";
}

/* ------------------------------
   SONG LIST (list.json)
------------------------------ */
let songs = [];

async function loadSongList() {
  const res = await fetch("notes/list.json");
  songs = await res.json();
}

/* ------------------------------
   MENU GENERATION
------------------------------ */
function buildSongMenu() {
  const list = document.getElementById("songList");
  list.innerHTML = "";

  songs.forEach((song, index) => {
    const div = document.createElement("div");
    div.innerHTML = `
      <button onclick="startGame(${index}, 'easy')">${song.title} (Easy)</button>
      <button onclick="startGame(${index}, 'hard')">${song.title} (Hard)</button>
    `;
    list.appendChild(div);
  });
}

/* ------------------------------
   GAME VARIABLES
------------------------------ */
let notes = [];
let startTime = 0;
let score = 0, combo = 0, maxCombo = 0;
let judgeCount = { Perfect: 0, Good: 0, Miss: 0 };
let lastJudgment = "", lastJudgmentTimer = 0;
let holdState = [null, null, null, null];
let audio = null;

const lanes = 4;
const laneWidth = canvas.width / lanes;
const hitY = 500;
const travelTime = 2.0;
const speed = (hitY + 50) / travelTime;

const perfectWindow = 0.06;
const goodWindow = 0.12;
const missWindow = 0.18;

const keyToLane = { s: 0, d: 1, k: 2, l: 3 };

document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (keyToLane[key] !== undefined) handleKeyDown(keyToLane[key]);
});
document.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if (keyToLane[key] !== undefined) handleKeyUp(keyToLane[key]);
});

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.touches[0].clientX - rect.left;
  const lane = Math.floor(x / laneWidth);
  handleKeyDown(lane);
});
canvas.addEventListener("touchend", e => {
  e.preventDefault();
  handleTouchEnd();
});

/* ------------------------------
   START GAME
------------------------------ */
async function startGame(songIndex, difficulty) {
  document.getElementById("menu").style.display = "none";
  document.getElementById("result").style.display = "none";
  document.getElementById("game").style.display = "block";

  const song = songs[songIndex];
  document.getElementById("songTitle").innerText =
    `${song.title} [${difficulty.toUpperCase()}]`;

  // Load chart
  const res = await fetch(song.json);
  const chart = await res.json();

  const bpm = chart.bpm;
  const pattern = chart.patterns[difficulty];

  // Generate notes
  notes = pattern.map(n => ({
    lane: n.lane,
    time: n.beat * 60 / bpm,
    hitTime: n.beat * 60 / bpm + travelTime,
    endTime: n.endBeat ? n.endBeat * 60 / bpm : null,
    endHitTime: n.endBeat ? n.endBeat * 60 / bpm + travelTime : null,
    type: n.type,
    judged: false,
    glow: 0,
    active: false
  }));

  // Reset game state
  score = 0;
  combo = 0;
  maxCombo = 0;
  judgeCount = { Perfect: 0, Good: 0, Miss: 0 };

  // Play audio
  audio = new Audio(song.audio);
  audio.play();

  startTime = performance.now() / 1000;
  update();
}

/* ------------------------------
   JUDGMENT
------------------------------ */
function judge(diff) {
  const ad = Math.abs(diff);
  if (ad <= perfectWindow) return "Perfect";
  if (ad <= goodWindow) return "Good";
  if (ad <= missWindow) return "Miss";
  return null;
}

function applyJudgment(note, result) {
  if (!result || note.judged) return;

  note.judged = true;
  note.glow = 0.2;

  judgeCount[result]++;
  if (result === "Perfect") { score += 1000; combo++; }
  else if (result === "Good") { score += 500; combo++; }
  else combo = 0;

  if (combo > maxCombo) maxCombo = combo;

  lastJudgment = result;
  lastJudgmentTimer = 0.5;
}

/* ------------------------------
   INPUT HANDLING
------------------------------ */
function handleKeyDown(lane) {
  const t = performance.now() / 1000 - startTime;

  let candidate = null;
  let minDiff = Infinity;

  for (let n of notes) {
    if (n.lane !== lane || n.judged) continue;
    const diff = t - n.hitTime;
    if (Math.abs(diff) < minDiff) {
      minDiff = Math.abs(diff);
      candidate = n;
    }
  }

  if (!candidate) return;

  const result = judge(t - candidate.hitTime);
  if (!result) return;

  if (candidate.type === "tap") {
    applyJudgment(candidate, result);
  } else {
    candidate.active = true;
    holdState[lane] = candidate;
  }
}

function handleKeyUp(lane) {
  const note = holdState[lane];
  if (!note) return;

  const t = performance.now() / 1000 - startTime;
  const result = judge(t - note.endHitTime);

  applyJudgment(note, result || "Miss");
  holdState[lane] = null;
}

function handleTouchEnd() {
  const t = performance.now() / 1000 - startTime;
  for (let lane = 0; lane < 4; lane++) {
    const note = holdState[lane];
    if (!note) continue;
    const result = judge(t - note.endHitTime);
    applyJudgment(note, result || "Miss");
    holdState[lane] = null;
  }
}

/* ------------------------------
   MAIN LOOP
------------------------------ */
function checkEnd(t) {
  let lastEnd = 0;
  for (let n of notes) {
    const end = n.type === "long" ? n.endHitTime : n.hitTime;
    if (end > lastEnd) lastEnd = end;
  }
  return t > lastEnd + 1.0;
}

function update() {
  const now = performance.now() / 1000;
  const t = now - startTime;

  if (checkEnd(t)) {
    showResult();
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground(t);

  // Lanes
  for (let i = 0; i < lanes; i++) {
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(i * laneWidth, 0, laneWidth - 2, canvas.height);
  }

  // Hit line
  ctx.fillStyle = "yellow";
  ctx.fillRect(0, hitY, canvas.width, 4);

  // Notes
  for (let n of notes) {
    const y = hitY - (n.hitTime - t) * speed;
    const x = n.lane * laneWidth + 10;
    const w = laneWidth - 20;

    if (!n.judged) {
      if (n.type === "tap" && t - n.hitTime > missWindow) applyJudgment(n, "Miss");
      if (n.type === "long" && t - n.endHitTime > missWindow) applyJudgment(n, "Miss");
    }

    if (!n.judged || n.type === "long") {
      ctx.fillStyle = n.glow > 0 ? "white" : (n.type === "tap" ? "cyan" : "lime");

      if (n.type === "tap") {
        ctx.fillRect(x, y - 10, w, 20);
      } else {
        const y2 = hitY - (n.endHitTime - t) * speed;
        const top = Math.min(y, y2);
        const h = Math.max(20, Math.abs(y - y2));
        ctx.fillRect(x, top, w, h);
      }
    }

    if (n.glow > 0) n.glow -= 1 / 60;
  }

  // HUD
  ctx.fillStyle = "white";
  ctx.font = "18px sans-serif";
  ctx.fillText("Score: " + score, 10, 25);
  ctx.fillText("Combo: " + combo, 10, 50);

  if (lastJudgmentTimer > 0) {
    lastJudgmentTimer -= 1 / 60;
    let color = "white";
    if (lastJudgment === "Perfect") color = "deepskyblue";
    else if (lastJudgment === "Good") color = "lime";
    else if (lastJudgment === "Miss") color = "red";

    ctx.fillStyle = color;
    ctx.font = "32px sans-serif";
    ctx.fillText(lastJudgment, canvas.width / 2 - 60, hitY - 40);
  }

  document.getElementById("info").innerText =
    `Score: ${score} / Combo: ${combo} / Max Combo: ${maxCombo}`;

  requestAnimationFrame(update);
}

/* ------------------------------
   BACKGROUND
------------------------------ */
function drawBackground(t) {
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "#001");
  grad.addColorStop(1, "#113");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 10; i++) {
    const y = (t * 50 + i * 60) % (canvas.height + 60) - 60;
    ctx.fillStyle = "rgba(0,150,255,0.15)";
    ctx.fillRect(0, y, canvas.width, 20);
  }
}

/* ------------------------------
   RESULT
------------------------------ */
function showResult() {
  document.getElementById("game").style.display = "none";
  document.getElementById("result").style.display = "block";

  document.getElementById("finalScore").innerText = "Score: " + score;
  document.getElementById("finalCombo").innerText = "Max Combo: " + maxCombo;
  document.getElementById("finalJudge").innerText =
    `Perfect: ${judgeCount.Perfect} / Good: ${judgeCount.Good} / Miss: ${judgeCount.Miss}`;
}

/* ------------------------------
   RETURN TO MENU
------------------------------ */
function returnToMenu() {
  document.getElementById("result").style.display = "none";
  document.getElementById("menu").style.display = "block";
}

/* ------------------------------
   INIT
------------------------------ */
window.onload = async function() {
  await loadSongList();
  buildSongMenu();
};
</script>

</body>
</html>
