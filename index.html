<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhythm Game PWA</title>

  <!-- Mobile optimization -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <!-- PWA manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- iOS PWA support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">

  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: sans-serif;
      text-align: center;
      overflow: hidden;
    }

    #menu, #game, #result {
      margin-top: 20px;
    }

    canvas {
      background: #111;
      display: block;
      margin: 10px auto;
      touch-action: none;
      max-width: 100vw;
      max-height: 90vh;
    }

    button {
      padding: 10px 18px;
      margin: 6px;
      font-size: 18px;
      border-radius: 8px;
    }

    h2 { font-size: 26px; }
    p  { font-size: 18px; }
  </style>
</head>

<!-- Firebase SDK -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getDatabase, ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDyXesDOgGoa1ZO1uO3hegmooRFcDcXYkU",
    authDomain: "game-count-c0cdc.firebaseapp.com",
    databaseURL: "https://game-count-c0cdc-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "game-count-c0cdc",
    storageBucket: "game-count-c0cdc.firebasestorage.app",
    messagingSenderId: "1004124857786",
    appId: "1:1004124857786:web:654e3287d33fcec8fd6983"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  window.db = db;
  window.firebaseRef = ref;
  window.firebaseGet = get;
  window.firebaseSet = set;
  window.firebaseOnValue = onValue;
</script>

<body>

<!-- MENU -->
<div id="menu">
  <h2>Select Song & Difficulty</h2>

  <p style="font-size:14px; color:#ccc; margin-bottom:20px;">
    This game is created for practice purposes.
  </p>

  <!-- 自動生成される曲リスト -->
  <div id="songList"></div>

  <p>PC: S / D / K / L | Mobile: Tap the lanes</p>
</div>

<!-- GAME -->
<div id="game" style="display:none;">
  <h2 id="songTitle"></h2>
  <canvas id="canvas"></canvas>
  <p id="info"></p>
</div>

<!-- RESULT -->
<div id="result" style="display:none;">
  <h2>Result</h2>
  <p id="finalScore"></p>
  <p id="finalCombo"></p>
  <p id="finalJudge"></p>
  <button onclick="returnToMenu()">Back to Menu</button>
</div>
<script>
/* ------------------------------
   DEVICE CHECK
------------------------------ */
function isMobileDevice() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
}

/* ------------------------------
   CANVAS SETUP
------------------------------ */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width  = 400;
canvas.height = 600;

if (isMobileDevice()) {
  canvas.style.width = (400 * 1.5) + "px";
  canvas.style.height = (600 * 1.5) + "px";
} else {
  canvas.style.width = "350px";
  canvas.style.height = "525px";
}

/* ------------------------------
   SONG LIST（list.json を読み込む）
------------------------------ */
let songs = [];

async function loadSongList() {
  try {
    const res = await fetch("notes/list.json");
    songs = await res.json();
  } catch (e) {
    console.error("list.json の読み込みに失敗:", e);
  }
}

/* ------------------------------
   MENU 自動生成
------------------------------ */
function buildSongMenu() {
  const list = document.getElementById("songList");
  list.innerHTML = "";

  songs.forEach((song, index) => {
    const div = document.createElement("div");

    div.innerHTML = `
      <button onclick="startGame(${index}, 'easy')">
        ${song.title} (Easy)
      </button>
      <button onclick="startGame(${index}, 'hard')">
        ${song.title} (Hard)
      </button>
    `;

    list.appendChild(div);
  });
}

/* ------------------------------
   PLAY COUNT（複数曲対応）
------------------------------ */
async function incrementPlayCount(songIndex, difficulty) {
  const key = `playcount/${songIndex}/${difficulty}`;
  const countRef = firebaseRef(window.db, key);

  const snapshot = await firebaseGet(countRef);
  let count = snapshot.exists() ? snapshot.val() : 0;

  count++;
  await firebaseSet(countRef, count);
}

function setupRealtimeCounts() {
  const playcountRef = firebaseRef(window.db, "playcount");

  firebaseOnValue(playcountRef, (snapshot) => {
    const data = snapshot.val() || {};

    songs.forEach((song, index) => {
      ["easy", "hard"].forEach(diff => {
        const id = `count-${index}-${diff}`;
        const value = data?.[index]?.[diff] ?? 0;

        const span = document.getElementById(id);
        if (span) span.textContent = value;
      });
    });
  });
}

/* ------------------------------
   ページ読み込み時の初期化
------------------------------ */
window.onload = async function() {
  await loadSongList();     // ← list.json を読み込む
  buildSongMenu();          // ← メニュー自動生成
  setupRealtimeCounts();    // ← Firebase カウント
};
</script>
<script>
/* ------------------------------
   START GAME（JSON 譜面読み込み）
------------------------------ */
async function startGame(songIndex, difficulty) {
  incrementPlayCount(songIndex, difficulty);

  document.getElementById("menu").style.display = "none";
  document.getElementById("result").style.display = "none";
  document.getElementById("game").style.display = "block";

  const song = songs[songIndex];
  difficultyLabel = difficulty;

  document.getElementById("songTitle").innerText =
    song.title + " [" + difficulty.toUpperCase() + "]";

  // JSON を読み込む
  const res = await fetch(song.json);
  const chart = await res.json();

  const bpm = chart.bpm;
  const pattern = chart.patterns[difficulty];

  // beat → 秒変換してノーツ生成
  notes = pattern.map(n => ({
    lane: n.lane,
    time: n.beat * 60 / bpm,
    hitTime: n.beat * 60 / bpm + travelTime,
    endTime: n.endBeat ? n.endBeat * 60 / bpm : null,
    endHitTime: n.endBeat ? n.endBeat * 60 / bpm + travelTime : null,
    type: n.type,
    judged: false,
    glow: 0,
    active: false
  }));

  score = 0;
  combo = 0;
  maxCombo = 0;
  judgeCount = { Perfect: 0, Good: 0, Miss: 0 };

  startTime = performance.now() / 1000;
  update();
}

/* ------------------------------
   JUDGMENT
------------------------------ */
function judge(diff) {
  const ad = Math.abs(diff);
  if (ad <= perfectWindow) return "Perfect";
  if (ad <= goodWindow) return "Good";
  if (ad <= missWindow) return "Miss";
  return null;
}

function applyJudgment(note, result) {
  if (!result || note.judged) return;

  note.judged = true;
  note.glow = 0.2;

  judgeCount[result]++;

  if (result === "Perfect") { score += 1000; combo++; }
  else if (result === "Good") { score += 500; combo++; }
  else combo = 0;

  if (combo > maxCombo) maxCombo = combo;

  lastJudgment = result;
  lastJudgmentTimer = 0.5;
}

/* ------------------------------
   KEY DOWN
------------------------------ */
function handleKeyDown(lane) {
  const t = performance.now() / 1000 - startTime;

  let candidate = null;
  let minDiff = Infinity;

  for (let n of notes) {
    if (n.lane !== lane || n.judged) continue;
    const diff = t - n.hitTime;
    if (Math.abs(diff) < minDiff) {
      minDiff = Math.abs(diff);
      candidate = n;
    }
  }

  if (!candidate) return;

  const result = judge(t - candidate.hitTime);
  if (!result) return;

  if (candidate.type === "tap") {
    applyJudgment(candidate, result);
  } else {
    candidate.active = true;
    holdState[lane] = candidate;
  }
}

/* ------------------------------
   KEY UP（ロングノーツ）
------------------------------ */
function handleKeyUp(lane) {
  const note = holdState[lane];
  if (!note) return;

  const t = performance.now() / 1000 - startTime;
  const result = judge(t - note.endHitTime);

  applyJudgment(note, result || "Miss");
  holdState[lane] = null;
}

/* ------------------------------
   TOUCH END（スマホ用）
------------------------------ */
function handleTouchEnd() {
  const t = performance.now() / 1000 - startTime;
  for (let lane = 0; lane < 4; lane++) {
    const note = holdState[lane];
    if (!note) continue;
    const result = judge(t - note.endHitTime);
    applyJudgment(note, result || "Miss");
    holdState[lane] = null;
  }
}
</script>
<script>
/* ------------------------------
   END CHECK
------------------------------ */
function checkEnd(t) {
  let lastEnd = 0;
  for (let n of notes) {
    const end = n.type === "long" ? n.endHitTime : n.hitTime;
    if (end > lastEnd) lastEnd = end;
  }
  return t > lastEnd + 1.0;
}

/* ------------------------------
   MAIN LOOP
------------------------------ */
function update() {
  const now = performance.now() / 1000;
  const t = now - startTime;

  if (checkEnd(t)) {
    showResult();
    return;
  }

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground(t);

  // Lanes
  for (let i = 0; i < lanes; i++) {
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(i * laneWidth, 0, laneWidth - 2, canvas.height);
  }

  // Hit line
  ctx.fillStyle = "yellow";
  ctx.fillRect(0, hitY, canvas.width, 4);

  // Notes
  for (let n of notes) {
    const y = hitY - (n.hitTime - t) * speed;
    const x = n.lane * laneWidth + 10;
    const w = laneWidth - 20;

    if (!n.judged) {
      if (n.type === "tap" && t - n.hitTime > missWindow) applyJudgment(n, "Miss");
      if (n.type === "long" && t - n.endHitTime > missWindow) applyJudgment(n, "Miss");
    }

    if (!n.judged || n.type === "long") {
      ctx.fillStyle = n.glow > 0 ? "white" : (n.type === "tap" ? "cyan" : "lime");

      if (n.type === "tap") {
        ctx.fillRect(x, y - 10, w, 20);
      } else {
        const y2 = hitY - (n.endHitTime - t) * speed;
        const top = Math.min(y, y2);
        const h   = Math.max(20, Math.abs(y - y2));
        ctx.fillRect(x, top, w, h);
      }
    }

    if (n.glow > 0) n.glow -= 1 / 60;
  }

  // HUD
  ctx.fillStyle = "white";
  ctx.font = "18px sans-serif";
  ctx.fillText("Score: " + score, 10, 25);
  ctx.fillText("Combo: " + combo, 10, 50);

  if (lastJudgmentTimer > 0) {
    lastJudgmentTimer -= 1 / 60;
    let color = "white";
    if (lastJudgment === "Perfect") color = "deepskyblue";
    else if (lastJudgment === "Good") color = "lime";
    else if (lastJudgment === "Miss") color = "red";

    ctx.fillStyle = color;
    ctx.font = "32px sans-serif";
    ctx.fillText(lastJudgment, canvas.width / 2 - 60, hitY - 40);
  }

  document.getElementById("info").innerText =
    `Score: ${score} / Combo: ${combo} / Max Combo: ${maxCombo}`;

  requestAnimationFrame(update);
}

/* ------------------------------
   BACKGROUND
------------------------------ */
function drawBackground(t) {
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "#001");
  grad.addColorStop(1, "#113");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 10; i++) {
    const y = (t * 50 + i * 60) % (canvas.height + 60) - 60;
    ctx.fillStyle = "rgba(0,150,255,0.15)";
    ctx.fillRect(0, y, canvas.width, 20);
  }
}

/* ------------------------------
   RESULT
------------------------------ */
function showResult() {
  document.getElementById("game").style.display = "none";
  document.getElementById("result").style.display = "block";

  document.getElementById("finalScore").innerText = "Score: " + score;
  document.getElementById("finalCombo").innerText = "Max Combo: " + maxCombo;
  document.getElementById("finalJudge").innerText =
    `Perfect: ${judgeCount.Perfect} / Good: ${judgeCount.Good} / Miss: ${judgeCount.Miss}`;
}

/* ------------------------------
   RETURN TO MENU
------------------------------ */
function returnToMenu() {
  document.getElementById("result").style.display = "none";
  document.getElementById("menu").style.display = "block";
}
</script>

</body>
</html>